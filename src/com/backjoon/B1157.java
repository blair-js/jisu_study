package com.backjoon;

import java.util.Scanner;

public class B1157 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine(); //문자열 입력받기
		
		//문자열을 구성하는 문자의 개수를 넣어줄 배열 선언
		//26개인 이유는? 문제에서 알파벳을 대/소문자 구분없이 세어준다고 했기 때문. 알파벳은 총 26개이다.
		//arr[0]부터 차례대로 a,b,c....z 를 넣을 공간이라고 생각하면 된다.
		int[] arr = new int[26];
		
		//입력받은 문자열의 길이만큼 반복을 통해 한글자 한글자 확인한다.
		for(int i=0; i<str.length(); i++) {
			
			//str의 i번째 문자에 따라 위에서 생성한 배열 arr의 원소 값을 증가시켜야 한다. 
			//예를들어 i번째 글자가 a나A라면 arr[0]의 값을 증가시키고, d나D라면 arr[3]의 값을 증가시킨다. 
			//이 때, 해당 문자에 따라 어떻게 배열 arr의 인덱스 위치를 찾아갈까? 
			//생각해보면 a나A는 arr[0]에 넣는다는건 우리가 가정했을뿐이다.
			//방법은 해당 문자와 우리가 가정한 인덱스의 위치의 규칙을 찾으면 된다. 
			//아스키 코드와 연관지어 생각해보면 아래의 규칙을 발견할 수 있다. 
			//소문자 => a의 아스키 코드는 97이다. 그럼 97을 빼주면 0이된다. b의 아스키코드는 98이다. 그럼 97을 빼면 1이 된다. 
			//대문자 => A의 아스키 코드는 65이다. 그럼 65를 빼주면 0이된다. B의 아스키코드는 66이다. 그럼 65를 빼면 1이 된다. 
			
			//문자열의 문자별 개수를 확인하여 배열에 담는 과정
			if(str.charAt(i) >= 65 && str.charAt(i) <= 90) { //문자열 str의 i번째 문자가 대문자라면(65이상 90이하)
				arr[str.charAt(i)-65]++;
			}else { //문자열 str의 i번째 문자가 대문자가 아니라면(소문자라면)
				arr[str.charAt(i)-97]++;
			}
		}//for
			
		//문자열의 개수중 가장 많은 개수를 갖고있는 문자를 찾는 과정 
		int max = -1; //최대값을 비교하기 위한 변수 지정
		char ch = '?'; //출력할 문자 지정
		
		//배열 arr의 모든 원소 반복을 통해 최대값 찾기 
		for(int i=0; i<26; i++) {
			//i번째 원소가 max보다 크면 해당 i번째 원소값을 max에 대입하고
			//해당 i번째 문자를 ch에 대입해준다.
			if(arr[i] > max) {
				max = arr[i];
				ch = (char)(i+65); //대문자로 출력을 해주어야 하므로 65를 더해준다. (소문자로 출력하라고 했다면 97을 더해주면 됨)
			}else if(arr[i] == max) { //근데 만약 최대값과 현재 i번째의 값이 같다면 ch를 물음표(?)로 대입
				ch = '?';
			}
		}//for
		
		System.out.println(ch); //최종적으로 ch 출력
		
	}

}
